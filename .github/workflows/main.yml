name: CI

# This is a basic workflow to help you get started with Actions
# Global Variables

env:
  AZUREAPPLICATIONINSIGHTSNAME:   "demo-performance-ai"
  CONTAINERREGISTRYNAME:          ""
  REPOSITORYNAME:                 ""
  IMAGETAG:                       ""
  AGENTVMSIZE:                    ""
  APPNAME:                        "finaltestdemo"
  KUBERNETESSERVICENAME:          "demo-performance-aks"
  AZURELOGANALYTICSWORKSPACENAME: "demo-performance-la-ws"
  AZURELOADTESTINGNAME:           "demo-performance-alt"
  CLUSTERIP:                      ""       

# # Controls when the workflow will run
# on:
#   # Triggers the workflow on push or pull request events but only for the main branch
#   push:
#     branches: [ master ]
on:
  workflow_dispatch:
    inputs:
      CONTAINERREGISTRYNAME:
        description: 'Set Container Registry Name'
        required: true
      REPOSITORYNAME:
        description: 'Set Image Name'
        required: true
      IMAGETAG:
        description: 'Set Image Tag'
        required: true
      AGENTVMSIZE:
        description: 'Choice Agent Virtual Machine Size'
        type: choice
        required: true
        options:
        - standard_d2s_v5
        - standard_d4s_v5
        - standard_d8s_v5

  # Allows you to run this workflow manually from the Actions tab
#  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build "
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Runs a single command using the runners shell
      - name: 'az version'
        run: az version

      # Checkout last version code from Main branch
      - name: Checkout last version code from Main branch
        uses: actions/checkout@main

      # Log into Azure
      - name: Log into Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Set env to Input 
      - name: Set the value
        id: step_one
        run: |
          echo "CONTAINERREGISTRYNAME=${{ github.event.inputs.CONTAINERREGISTRYNAME }}" >> $GITHUB_ENV
          echo "REPOSITORYNAME=${{ github.event.inputs.REPOSITORYNAME }}" >> $GITHUB_ENV
          echo "AGENTVMSIZE=${{ github.event.inputs.AGENTVMSIZE }}" >> $GITHUB_ENV
          echo "IMAGETAG=${{ github.event.inputs.IMAGETAG }}" >> $GITHUB_ENV

      # # Deploy Bicep file Application Insights 
      # - name: Deploy Bicep file Application Insights 
      #   uses: azure/arm-deploy@v1
      #   with:
      #     subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION }}
      #     resourceGroupName: ${{ secrets.AZURE_RG }}
      #     template: ./Bicep/AAI/mainAAI.bicep
      #     parameters: name="${{ env.AZUREAPPLICATIONINSIGHTSNAME }}" location="westeurope"
      #     failOnStdErr: false

      # # Deploy Bicep file Application Gateway
      # - name: Deploy Bicep file Application Gateway
      #   id: Gateway
      #   uses: azure/arm-deploy@v1
      #   with:
      #     subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION }}
      #     resourceGroupName: ${{ secrets.AZURE_RG }}
      #     template: ./Bicep/AAG/mainAAG.bicep
      #     failOnStdErr: false

      # Deploy Bicep file Kubernetes service
      - name: Deploy Bicep file Kubernetes service
        id: Kubernetes
        uses: azure/arm-deploy@v1
        with:
          subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION }}
          resourceGroupName: ${{ secrets.AZURE_RG }}
          template: ./Bicep/AKS/mainAKS.bicep
          parameters: name="${{ env.KUBERNETESSERVICENAME }}" agentVMSize="${{ env.AGENTVMSIZE}}"
          failOnStdErr: false

      # Kubectl tool installer
      - name: Kubectl tool installer
        uses: Azure/setup-kubectl@v2.1
        
      # Deploy Nginx Reverse Proxy service to Kubernetes
      - name: Deploy Nginx Reverse Proxy service to Kubernetes
        run: |
          az aks get-credentials -n "${{ env.KUBERNETESSERVICENAME }}" -g "${{ secrets.AZURE_RG }}" 
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade nginx ingress-nginx/ingress-nginx --install

      # # Assign IP to Target Backend Pool
      # - name: Assign IP to Target Backend Pool
      #   run: |
      #     az aks get-credentials --resource-group "${{ secrets.AZURE_RG }}" --name "${{ steps.Kubernetes.outputs.name }}" 
      #     $ip = kubectl get services --namespace default nginx-ingress-nginx-controller --output jsonpath='{.status.loadBalancer.ingress[0].ip}'
      #     az network application-gateway address-pool update --gateway-name "${{ steps.Gateway.outputs.applicationGatewayName }}" --name "${{ steps.Gateway.outputs.backendPoolName }}" --resource-group "${{ secrets.AZURE_RG }}" --servers $ip
      #   shell: pwsh

      # Assign role to Kubernetes service user to access Container Registry image
      - name: Assign role to Kubernetes service user to access Container Registry image 
        run: |
          sleep 15
          az aks update -n "${{ env.KUBERNETESSERVICENAME }}" -g "${{ secrets.AZURE_RG }}" --attach-acr "${{ env.CONTAINERREGISTRYNAME }}"

      # Deploy Container registry image to Kubernetes service 
      - name: Deploy Container registry image to Kubernetes service
        run: |
          cd src/helloworld-service/user-service-chart
          helm upgrade ${{ env.APPNAME }} . --install --set image.repository=${{ env.CONTAINERREGISTRYNAME }}.azurecr.io/${{ env.REPOSITORYNAME }} --set image.tag=${{ env.IMAGETAG }} --set app.name=${{ env.APPNAME }} --namespace "demo-performance" --create-namespace  
          echo "CLUSTERIP=$(kubectl get service "nginx-ingress-nginx-controller" -n default -o jsonpath="{.status.loadBalancer.ingress[0].ip}")" >> $GITHUB_ENV

      # Deploy Prometheus service to Kubernetes
      - name: Deploy Prometheus service to Kubernetes
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm upgrade --install prometheus-stack prometheus-community/kube-prometheus-stack --values src/helloworld-service/prometheus.values.demo.yaml --wait --debug --atomic --timeout 600s --namespace "prometheus" --create-namespace

      # # Deploy Bicep file Log Analytics workspace
      # - name: Deploy Bicep file Log Analytics workspace
      #   uses: azure/arm-deploy@v1
      #   with:
      #     subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION }}
      #     resourceGroupName: ${{ secrets.AZURE_RG }}
      #     template: ./Bicep/ALA/mainALA.bicep
      #     parameters: name="${{ env.AZURELOGANALYTICSWORKSPACENAME }}"  location="westeurope"
      #     failOnStdErr: false

      # Set up Chaos Mesh on your AKS cluster
      - name: Set up Chaos Mesh on your AKS cluster
        run: |
          helm repo add chaos-mesh https://charts.chaos-mesh.org
          helm repo update
          helm install chaos-mesh chaos-mesh/chaos-mesh --set chaosDaemon.runtime=containerd --set chaosDaemon.socketPath=/run/containerd/containerd.sock --namespace "chaos-testing" --create-namespace

      # Deploy Chaos Studio Experiments
      - name: Deploy Chaos Studio Experiments
        run: |
          $RESOURCE_ID = ${{ steps.Kubernetes.outputs.id }}
          $AKS_NAME = ${{ env.KUBERNETESSERVICENAME }}
          $RESOURCE_GROUP = ${{ secrets.AZURE_RG }}
          $SUBSCRIPTION_ID = ${{ secrets.AZURE_SUBSCRIPTION }}
          $EXPERIMENT_NAME = "Experiment1"         
          az rest --method put --url "https://management.azure.com/$RESOURCE_ID/providers/Microsoft.Chaos/targets/Microsoft-AzureKubernetesServiceChaosMesh?api-version=2021-09-15-preview" --body '{\"properties\":{}}'
          az rest --method put --url "https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.ContainerService/managedClusters/$AKS_NAME/providers/Microsoft.Chaos/targets/Microsoft-AzureKubernetesServiceChaosMesh/capabilities/PodChaos-2.1?api-version=2021-09-15-preview"  --body '{\"properties\":{}}'
          $EXPERIMENT_PRINCIPAL_ID = az rest --method put --uri https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Chaos/experiments/$EXPERIMENT_NAME?api-version=2021-09-15-preview --body '@experiment.json' --query identity.principalId
          az role assignment create --role "Azure Kubernetes Service Cluster Admin Role" --assignee-object-id $EXPERIMENT_PRINCIPAL_ID --scope $RESOURCE_ID

      # Run Chaos Experiments
      - name: Run Chaos Experiments
        run: |
          $RESOURCE_GROUP = ${{ secrets.AZURE_RG }}
          $SUBSCRIPTION_ID = ${{ secrets.AZURE_SUBSCRIPTION }}
          $EXPERIMENT_NAME = "Experiment1"    
          az rest --method post --uri https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Chaos/experiments/$EXPERIMENT_NAME/start?api-version=2021-09-15-preview

      # Deploy Bicep file Azure Load Testing
      - name: Deploy Bicep file Azure Load Testing
        uses: azure/arm-deploy@v1
        with:
          subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION }}
          resourceGroupName: ${{ secrets.AZURE_RG }}
          template: ./Bicep/ALT/mainALT.bicep
          parameters: name="${{ env.AZURELOADTESTINGNAME }}" location="northeurope"
          failOnStdErr: false

      # https://github.com/Azure/load-testing
      - name: 'Create Azure Load Test'
        uses: azure/load-testing@v1
        with:
          resourceGroup: ${{ secrets.AZURE_RG }}
          loadTestResource: "${{ env.AZURELOADTESTINGNAME }}"
          loadTestConfigFile: ./Bicep/ALT/config.yaml
          env: |
            [
                {
                "name": "webapp",
                "value": "${{ env.CLUSTERIP }}"
                }
            ]

